#[derive(Debug, Clone, PartialEq)]
pub enum TokenType {
    // Control chars
    Sp,
    NL,
    Comment(String),
    Indent(usize),

    // Special chars
    // {
    PunctBraceL,
    // }
    PunctBraceR,
    // [
    PunctBracketL,
    // ]
    PunctBracketR,
    // (
    PunctParenL,
    // )
    PunctParenR,
    // :
    PunctColon,
    // ::
    PunctDoubleColon,
    // =>
    PunctFatArrow,
    // !
    PunctExclamation,

    // Literals
    LitString(String),
    LitBoolean(String),
    LitNumber(String),

    // Identities
    IdPackage(String),
    IdType(String),
    IdVar(String),
    IdFunc(String),
    IdTrait(String),

    // Primitives
    PrBool,
    PrByte,
    PrFloat,
    PrFloat32,
    PrFloat64,
    PrInt,
    PrInt8,
    PrInt16,
    PrInt32,
    PrInt64,
    PrStr,
    PrString,
    PrUInt,
    PrUInt8,
    PrUInt16,
    PrUInt32,
    PrUInt64,

    // Keywords
    KwAs,
    KwBreak,
    KwCase,
    KwConst,
    KwContinue,
    KwElse,
    KwElseIf,
    KwEnum,
    KwFn,
    KwFor,
    KwIf,
    KwImpl,
    KwIn,
    KwLazy,
    KwLet,
    KwMatch,
    KwReturn,
    KwSelf,
    KwStruct,
    KwTest,
    KwTestCase,
    KwThen,
    KwTrait,
    KwType,
    KwWhile,

    // Package keywords
    KwPackage,
    KwDescription,
    KwVersion,
    KwDependencies,
    KwExport,
    KwImport,
    KwFiles,

    // BuiltIns
    BuiltInTypeOption,
    BuiltInTypeList,
    BuiltInTypeMap,
    BuiltInTypeMaybe,
    BuiltInTypeSelf,
    BuiltInTypeSet,

    // Conditional operators
    OpEqEq,
    OpNotEq,
    OpGte,
    OpGt,
    OpLte,
    OpLt,

    // Math operators
    OpAdd,
    OpSub,
    OpMul,
    OpDiv,
    OpFloorDiv,
    OpMod,
    OpPow,

    // Assignment operators
    OpAssignEq,
    OpAssignAdd,
    OpAssignSub,
    OpAssignDiv,
    OpAssignMul,
    OpAssignPow,
    OpAssignMod,
    OpAssignFloorDiv,
    OpAssignBitwiseAnd,
    OpAssignBitwiseOr,
    OpAssignBitwiseXOr,
    OpAssignBitwiseShiftL,
    OpAssignBitwiseShiftR,

    // Logical operators
    OpLogicalAnd,
    OpLogicalOr,
    OpLogicalNot,

    // Unary operators
    OpUnaryNot,
    OpUnaryMinus,
    OpUnaryPlus,

    // Bitwise operators
    OpBitwiseShiftL,
    OpBitwiseShiftR,
    OpBitwiseAnd,
    OpBitwiseOr,
    OpBitwiseXOr,
}

impl Into<String> for TokenType {
    fn into(self) -> String {
        match self {
            TokenType::Sp => " ".into(),
            TokenType::NL => "\n".into(),
            TokenType::Comment(s) => s,
            TokenType::Indent(size) => " ".repeat(size),
            TokenType::PunctBraceL => "{".into(),
            TokenType::PunctBraceR => "}".into(),
            TokenType::PunctBracketL => "[".into(),
            TokenType::PunctBracketR => "]".into(),
            TokenType::PunctParenL => "(".into(),
            TokenType::PunctParenR => ")".into(),
            TokenType::PunctColon => ":".into(),
            TokenType::PunctDoubleColon => "::".into(),
            TokenType::PunctFatArrow => "=>".into(),
            TokenType::PunctExclamation => "!".into(),
            TokenType::LitString(s) => s,
            TokenType::LitBoolean(s) => s,
            TokenType::LitNumber(s) => s,
            TokenType::IdPackage(s) => s,
            TokenType::IdType(s) => s,
            TokenType::IdVar(s) => s,
            TokenType::IdFunc(s) => s,
            TokenType::IdTrait(s) => s,
            TokenType::PrBool => "bool".into(),
            TokenType::PrByte => "byte".into(),
            TokenType::PrFloat => "float".into(),
            TokenType::PrFloat32 => "float32".into(),
            TokenType::PrFloat64 => "float64".into(),
            TokenType::PrInt => "int".into(),
            TokenType::PrInt8 => "int8".into(),
            TokenType::PrInt16 => "int16".into(),
            TokenType::PrInt32 => "int32".into(),
            TokenType::PrInt64 => "int64".into(),
            TokenType::PrStr => "str".into(),
            TokenType::PrString => "string".into(),
            TokenType::PrUInt => "uint".into(),
            TokenType::PrUInt8 => "uint8".into(),
            TokenType::PrUInt16 => "uint16".into(),
            TokenType::PrUInt32 => "uint32".into(),
            TokenType::PrUInt64 => "uint64".into(),
            TokenType::KwAs => "as".into(),
            TokenType::KwBreak => "break".into(),
            TokenType::KwCase => "case".into(),
            TokenType::KwConst => "const".into(),
            TokenType::KwContinue => "continue".into(),
            TokenType::KwElse => "else".into(),
            TokenType::KwElseIf => "elif".into(),
            TokenType::KwEnum => "enum".into(),
            TokenType::KwFn => "fn".into(),
            TokenType::KwFor => "for".into(),
            TokenType::KwIf => "if".into(),
            TokenType::KwIn => "in".into(),
            TokenType::KwImpl => "impl".into(),
            TokenType::KwLazy => "lazy".into(),
            TokenType::KwLet => "let".into(),
            TokenType::KwMatch => "match".into(),
            TokenType::KwReturn => "return".into(),
            TokenType::KwSelf => "self".into(),
            TokenType::KwStruct => "struct".into(),
            TokenType::KwTest => "test".into(),
            TokenType::KwTestCase => "testcase".into(),
            TokenType::KwThen => "then".into(),
            TokenType::KwTrait => "trait".into(),
            TokenType::KwType => "type".into(),
            TokenType::KwWhile => "while".into(),
            TokenType::KwPackage => "package".into(),
            TokenType::KwDescription => "description".into(),
            TokenType::KwVersion => "version".into(),
            TokenType::KwDependencies => "dependencies".into(),
            TokenType::KwFiles => "files".into(),
            TokenType::KwExport => "export".into(),
            TokenType::KwImport => "import".into(),
            TokenType::BuiltInTypeOption => "Option".into(),
            TokenType::BuiltInTypeList => "List".into(),
            TokenType::BuiltInTypeMap => "Map".into(),
            TokenType::BuiltInTypeMaybe => "Maybe".into(),
            TokenType::BuiltInTypeSelf => "Self".into(),
            TokenType::BuiltInTypeSet => "Set".into(),
            TokenType::OpEqEq => "==".into(),
            TokenType::OpNotEq => "!=".into(),
            TokenType::OpGte => ">=".into(),
            TokenType::OpGt => ">".into(),
            TokenType::OpLte => "<=".into(),
            TokenType::OpLt => "<".into(),
            TokenType::OpAdd => "+".into(),
            TokenType::OpSub => "-".into(),
            TokenType::OpMul => "*".into(),
            TokenType::OpDiv => "/".into(),
            TokenType::OpFloorDiv => "//".into(),
            TokenType::OpMod => "%".into(),
            TokenType::OpPow => "**".into(),
            TokenType::OpAssignAdd => "+=".into(),
            TokenType::OpAssignDiv => "/=".into(),
            TokenType::OpAssignEq => "=".into(),
            TokenType::OpAssignMul => "*=".into(),
            TokenType::OpAssignSub => "-=".into(),
            TokenType::OpBitwiseAnd => "&".into(),
            TokenType::OpBitwiseOr => "|".into(),
            TokenType::OpBitwiseShiftL => "<<".into(),
            TokenType::OpBitwiseShiftR => ">>".into(),
            TokenType::OpBitwiseXOr => "^".into(),
            TokenType::OpLogicalAnd => "&&".into(),
            TokenType::OpLogicalNot => "!".into(),
            TokenType::OpLogicalOr => "||".into(),

            TokenType::OpUnaryNot => "!".into(),
            TokenType::OpUnaryMinus => "-".into(),
            TokenType::OpUnaryPlus => "+".into(),
            TokenType::OpAssignPow => "**=".into(),
            TokenType::OpAssignMod => "%=".into(),
            TokenType::OpAssignFloorDiv => "//=".into(),
            TokenType::OpAssignBitwiseAnd => "&=".into(),
            TokenType::OpAssignBitwiseOr => "|=".into(),
            TokenType::OpAssignBitwiseXOr => "^=".into(),
            TokenType::OpAssignBitwiseShiftL => "<<=".into(),
            TokenType::OpAssignBitwiseShiftR => ">>=".into(),
        }
    }
}

impl TokenType {
    pub fn builtins() -> Vec<Self> {
        vec![
            Self::BuiltInTypeOption,
            Self::BuiltInTypeList,
            Self::BuiltInTypeMap,
            Self::BuiltInTypeMaybe,
            Self::BuiltInTypeSelf,
            Self::BuiltInTypeSet,
        ]
    }

    pub fn primitives() -> Vec<Self> {
        vec![
            Self::PrBool,
            Self::PrByte,
            Self::PrFloat,
            Self::PrFloat32,
            Self::PrFloat64,
            Self::PrInt,
            Self::PrInt8,
            Self::PrInt16,
            Self::PrInt32,
            Self::PrInt64,
            Self::PrStr,
            Self::PrString,
            Self::PrUInt,
            Self::PrUInt8,
            Self::PrUInt16,
            Self::PrUInt32,
            Self::PrUInt64,
        ]
    }

    pub fn operators() -> Vec<Self> {
        vec![
            Self::OpEqEq,
            Self::OpNotEq,
            Self::OpGte,
            Self::OpGt,
            Self::OpLte,
            Self::OpLt,
            Self::OpAdd,
            Self::OpSub,
            Self::OpMul,
            Self::OpDiv,
            Self::OpMod,
            Self::OpPow,
            Self::OpAssignEq,
            Self::OpAssignAdd,
            Self::OpAssignSub,
            Self::OpAssignDiv,
            Self::OpAssignMul,
            Self::OpAssignPow,
            Self::OpAssignMod,
            Self::OpAssignFloorDiv,
            Self::OpAssignBitwiseAnd,
            Self::OpAssignBitwiseOr,
            Self::OpAssignBitwiseXOr,
            Self::OpAssignBitwiseShiftL,
            Self::OpAssignBitwiseShiftR,
            Self::OpLogicalAnd,
            Self::OpLogicalNot,
            Self::OpLogicalOr,
            Self::OpBitwiseAnd,
            Self::OpBitwiseOr,
            Self::OpFloorDiv,
            Self::OpBitwiseShiftL,
            Self::OpBitwiseShiftR,
            Self::OpBitwiseXOr,
        ]
    }
}
